import{a as P,b as F,d as u}from"./chunk-OWCFWPAL.js";import{useEffect as pt}from"react";import{create as yt}from"zustand";var Ee=yt(()=>({status:"disconnected"})),Ce=()=>Ee.getState().onNeedsRecovery,pr=e=>{pt(()=>{Ee.setState({onNeedsRecovery:e==null?void 0:e.onNeedsRecovery})},[e==null?void 0:e.onNeedsRecovery])};import{applicationId as Re}from"expo-application";import*as A from"expo-secure-store";import{PrivyClientError as mt}from"@privy-io/js-sdk-core";var ke=()=>{if(typeof Re!="string")throw new mt({error:"Cannot determine native application ID. Please make sure `expo-application` is installed as a dependency and that `ios.bundleId` or `android.package` is set.",code:"invalid_native_app_id"});return Re};function Pe(e){return{get(t){return e.get(t.replaceAll(":","-"))},put(t,r){return e.put(t.replaceAll(":","-"),r)},del(t){return e.del(t.replaceAll(":","-"))},getKeys:()=>u(this,null,function*(){return[]})}}var Z={get(e){return A.getItemAsync(e,{keychainAccessible:A.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},put(e,t){return A.setItemAsync(e,t,{keychainAccessible:A.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},del(e){return A.deleteItemAsync(e,{keychainAccessible:A.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},getKeys:()=>u(void 0,null,function*(){return[]})};import{digest as ft}from"expo-crypto";import bt from"@privy-io/js-sdk-core";var Ae={name:"@privy-io/expo",version:"0.55.3",description:"Expo client for the Privy Auth API",keywords:["authentication","authorization","identity","privacy","privy","user data","react-native","expo","web3"],homepage:"https://docs.privy.io",bugs:{url:"https://privy.io/slack"},license:"Apache-2.0",author:"privy.io",exports:{".":{require:"./dist/index.js",import:"./dist/esm/index.js",types:"./dist/index.d.ts"},"./passkey":{require:"./dist/passkey.js",import:"./dist/esm/passkey.js",types:"./dist/passkey.d.ts"},"./smart-wallets":{require:"./dist/smart-wallets.js",import:"./dist/esm/smart-wallets.js",types:"./dist/smart-wallets.d.ts"},"./extended-chains":{require:"./dist/extended-chains.js",import:"./dist/esm/extended-chains.js",types:"./dist/extended-chains.d.ts"},"./ui":{require:"./dist/ui.js",import:"./dist/esm/ui.js",types:"./dist/ui.d.ts"},"./connectors":{require:"./dist/connectors.js",import:"./dist/esm/connectors.js",types:"./dist/connectors.d.ts"}},main:"./dist/esm/index.js",source:"./src/index.ts",types:"./dist/index.d.ts",files:["dist/**/*","LICENSE","README.md"],scripts:{build:"tsup --clean --minify","check-types":"tsc --noEmit",clean:"rm -rf dist .turbo",dev:"tsup --watch",format:'eslint "src/**/*.{ts,tsx,js,jsx}" --fix',"generate-types":"tsup --dts-only",lint:'eslint "src/**/*.{ts,tsx,js,jsx}"',test:"jest"},browserslist:["defaults","node >= 18","not op_mini all"],dependencies:{"@privy-io/js-sdk-core":"0.52.3","@scure/base":"^1.2.4",tweetnacl:"^1.0.3","react-fast-compare":"^3.2.2",zustand:"^5.0.4"},devDependencies:{"@privy-io/eslint-config-custom":"*","@privy-io/tsconfig":"*","@simplewebauthn/types":"9.0.1","@solana/web3.js":"^1.98.0","@svgr/core":"^8.1.0","@svgr/plugin-jsx":"^8.1.0","@svgr/plugin-svgo":"^8.1.0","@testing-library/react-native":"^13.1.0","@tsconfig/node16-strictest-esm":"^1.0.3","@types/jest":"^29.1.2",buffer:"^5.4.3","eslint-plugin-react-hooks":"^5.0.0-canary-7118f5dd7-20230705",expo:"52.0.37","expo-apple-authentication":"7.1.3","expo-application":"6.0.2","expo-clipboard":"7.0.1","expo-crypto":"14.0.2",jest:"^29.7.0","jest-expo":"52.0.5","lucide-react-native":"^0.474.0",react:"^18.3.1","react-native":"0.77.1","react-test-renderer":"^18.3.1",tsup:"^6.2.3",typescript:"~5.5.3"},peerDependencies:{"@expo-google-fonts/inter":"*","@privy-io/expo-native-extensions":"0.0.5","expo-apple-authentication":"*","expo-application":"*","expo-clipboard":"*","expo-crypto":"*","expo-font":"*","expo-linking":"*","expo-secure-store":"*","expo-web-browser":"*",permissionless:"^0.2.47",react:"*","react-native":"*","react-native-passkeys":"^0.3.0","react-native-qrcode-styled":"*","react-native-safe-area-context":"*","react-native-svg":"*","react-native-webview":"*",viem:"^2.30.6"},peerDependenciesMeta:{"@expo-google-fonts/inter":{optional:!0},"expo-font":{optional:!0},permissionless:{optional:!0},viem:{optional:!0},"react-native-svg":{optional:!0},"expo-clipboard":{optional:!0},"react-native-qrcode-styled":{optional:!0},"react-native-safe-area-context":{optional:!0}},publishConfig:{access:"public"}};var xe=({appId:e,clientId:t,storage:r=Z,supportedChains:o,baseUrl:n,logLevel:d})=>new bt({appId:e,clientId:t,supportedChains:o,storage:Pe(r),sdkVersion:`expo:${Ae.version}`,nativeAppIdentifier:ke(),crypto:{digest:ft},baseUrl:n,logLevel:d});import B,{useState as k,useMemo as tr,createContext as rr,useCallback as ie,useRef as z,useEffect as et,useContext as or}from"react";import{AppState as tt,View as ar}from"react-native";import{PrivyClientError as rt}from"@privy-io/js-sdk-core";import wt from"react-fast-compare";import{create as St}from"zustand";var ee=St(()=>{}),We=e=>ee.setState(t=>wt(t,e)?t:e),Oe=ee.getState;import _t from"react";import{useCallback as Et,useEffect as Ct,useRef as Rt}from"react";import{AppState as kt}from"react-native";import Pt from"react-native-webview";import*as x from"expo-secure-store";function Ie(e){return typeof e!="object"||e===null||!("event"in e&&typeof e.event=="string")||!("id"in e&&typeof e.id=="string")||!("data"in e&&typeof e.data=="object")||e.data===null?!1:e.event.startsWith("app:secure-storage:")}function Ue(e){return u(this,null,function*(){switch(e.event){case"app:secure-storage:get":{let{key:t}=e.data,r=yield x.getItemAsync(pe(t),{keychainAccessible:x.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).catch(o=>(console.warn("Failed to get the value from secure store",o),null));return{event:e.event,id:e.id,data:{value:r}}}case"app:secure-storage:remove":{let{key:t}=e.data,r=yield x.deleteItemAsync(pe(t),{keychainAccessible:x.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).then(()=>!0).catch(o=>(console.warn("Failed to remove the value from secure store",o),!1));return{event:e.event,id:e.id,data:{success:r}}}case"app:secure-storage:set":{let{key:t,value:r}=e.data,o=yield x.setItemAsync(pe(t),r,{keychainAccessible:x.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).then(()=>!0).catch(n=>(console.warn("Failed to write the value to secure store",n),!1));return{event:e.event,id:e.id,data:{success:o}}}}})}var pe=e=>e.replaceAll(":","-");import ht from"react-fast-compare";import{createStore as gt,useStore as ye}from"zustand";var I=gt()(()=>({user:null,proxyStatus:"loading"}));function Or(){return I.getState().user}var Ir=I.subscribe.bind(I);function me(e){I.setState(({user:t})=>ht(t,e)?{}:{user:e})}var ve=e=>I.setState({proxyStatus:e});function U(){return ye(I,e=>e.user)}function Ur(){return ye(I,e=>!!e.user)}function T(){return ye(I,e=>e.proxyStatus!=="loading")}var At={shouldUseAppBackedStorage:!0},Te=({client:e,isClientReady:t})=>{let r=Rt(null);Ct(()=>kt.addEventListener("change",d=>u(void 0,null,function*(){d==="active"&&((yield e.embeddedWallet.ping(500))||(ve("reloading"),e.embeddedWallet.reload()))})).remove,[e]);let o=Et(n=>u(void 0,null,function*(){var c;let{data:d}=n.nativeEvent,i=JSON.parse(d);if(Ie(i)){let s=yield Ue(i);(c=r.current)==null||c.postMessage(JSON.stringify(s));return}e.embeddedWallet.onMessage(i)}),[e]);return t?_t.createElement(Pt,{style:{flex:1},ref:n=>{n&&(e.setMessagePoster(n),r.current=n)},cacheEnabled:!1,cacheMode:"LOAD_NO_CACHE",injectedJavaScriptObject:At,source:{uri:e.embeddedWallet.getURL()},webviewDebuggingEnabled:e.logger.level==="DEBUG",onLoad:()=>ve("loaded"),onError:console.error,onMessage:o}):null};import{useCallback as fe,useEffect as Ne,useMemo as be}from"react";import{errorIndicatesRecoveryIsNeeded as Wt,getAllUserEmbeddedSolanaWallets as Ot,getEntropyDetailsFromUser as je,PrivyClientError as H}from"@privy-io/js-sdk-core";import{getAllUserEmbeddedSolanaWallets as te,getEntropyDetailsFromAccount as Fe,getUserEmbeddedEthereumWallet as xt,PrivyClientError as j}from"@privy-io/js-sdk-core";function Me(d){return u(this,arguments,function*({client:e,setSolanaWallet:t,createSolanaWalletCallbacks:r,setSolanaRecoveryFlowState:o,opts:n}){var i,c,s;t({status:"creating"});try{let{user:a}=yield e.user.get(),p=te(a),w=p[0],v=(i=xt(a))!=null?i:void 0;if(n!=null&&n.recoveryMethod&&n.recoveryMethod!=="privy")throw new j({code:"embedded_wallet_creation_error",error:"Unsupported recovery method for solana wallet."});if(!(n!=null&&n.createAdditional)&&w)throw new j({code:"embedded_wallet_creation_error",error:"Solana wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let S,m;if(w){let l=v!=null?v:w,{entropyId:b,entropyIdVerifier:y}=Fe(l),h=Math.max(...p.map(E=>E.wallet_index),0)+1,g=yield e.embeddedWallet.add({chainType:"solana",entropyId:b,entropyIdVerifier:y,hdWalletIndex:h}),_=te(g.user).find(E=>E.wallet_index===h);if(!_)throw new j({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});S=yield e.embeddedWallet.getSolanaProvider(_,b,y),m=g.user}else{let l=yield e.embeddedWallet.createSolana({ethereumAccount:v}),b=te(l.user).find(_=>_.wallet_index===0);if(!b)throw new j({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});let y=v!=null?v:b,{entropyId:h,entropyIdVerifier:g}=Fe(y);S=yield e.embeddedWallet.getSolanaProvider(b,h,g),m=l.user}let f=te(m)[0];if(!f)throw new j({code:"embedded_wallet_creation_error",error:"Unknown error creating solana wallet"});return(s=(c=r.current)==null?void 0:c.onSuccess)==null||s.call(c,S),t({status:"connected",publicKey:f.public_key}),o({status:"initial"}),S}catch(a){let p=a instanceof Error?a.message:"Error creating embedded wallet";throw t({status:"error",error:p}),o({status:"initial"}),new j({code:"embedded_wallet_creation_error",error:p})}})}import{PrivyClientError as M}from"@privy-io/js-sdk-core";function re(p){return u(this,arguments,function*({client:e,account:t,setWallet:r,recoverWalletCallbacks:o,recoveryMethod:n,setRecoveryFlowState:d,password:i,recoveryKey:c,recoveryToken:s,recoverySecretOverride:a}){var w,v,S,m;if(!t)throw new M({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});switch(n){case"user-passcode":if(!i)throw new M({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!s)throw new M({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!a)throw new M({code:"embedded_wallet_recovery_error",error:"Record name is required for icloud recovery method"});break;case"recovery-encryption-key":if(!c)throw new M({code:"embedded_wallet_recovery_error",error:"recoveryKey is required for recovery-encryption-key recovery method"});break}r({status:"connecting",account:t});try{let f=yield e.embeddedWallet.getProvider(t,i,s,a,c);return r({status:"connected",provider:f,account:t}),d({status:"initial"}),(v=(w=o.current)==null?void 0:w.onSuccess)==null||v.call(w,f),f}catch(f){r({status:"needs-recovery",account:t}),d({status:"initial"});let l=new M({code:"embedded_wallet_recovery_error",error:f instanceof Error?f.message:"Error recovering embedded wallet"});throw(m=(S=o.current)==null?void 0:S.onError)==null||m.call(S,l),l}})}function Le(c){return u(this,arguments,function*({client:e,account:t,entropyId:r,entropyIdVerifier:o,setSolanaWallet:n,recoverSolanaWalletCallbacks:d,setSolanaRecoveryFlowState:i}){var s,a,p,w;n({status:"connecting"});try{let v=yield e.embeddedWallet.getSolanaProvider(t,r,o);return n({status:"connected",publicKey:v._publicKey}),i({status:"initial"}),(a=(s=d.current)==null?void 0:s.onSuccess)==null||a.call(s,v),v}catch(v){n({status:"needs-recovery"}),i({status:"initial"});let S=new M({code:"embedded_wallet_recovery_error",error:v instanceof Error?v.message:"Error recovering embedded wallet"});throw(w=(p=d.current)==null?void 0:p.onError)==null||w.call(p,S),S}})}var De=({client:e,solanaWallet:t,setSolanaWallet:r,setSolanaRecoveryFlowState:o,createSolanaWalletCallbacks:n,recoverSolanaWalletCallbacks:d})=>{let i=U(),c=be(()=>Ot(i),[i]),s=T(),a=be(()=>c.length===0?null:je(i),[i,c]),p=be(()=>{let m=c.map(y=>{let h=je(i,y);return h?{account:y,entropy:h}:null});if(m.some(y=>y===null))return[];let f=void 0,l=void 0,b=void 0;return m.filter(y=>y!==null).map(({account:y,entropy:{entropyId:h,entropyIdVerifier:g}})=>({address:y.address,publicKey:y.address,walletIndex:y.wallet_index,getProvider:()=>e.embeddedWallet.getSolanaProvider(y,h,g,f,l,b,_=>u(void 0,null,function*(){var E;yield(E=Ce())==null?void 0:E(_)}))}))},[c,i,e]),w=fe(m=>u(void 0,null,function*(){return yield Me({client:e,setSolanaWallet:r,createSolanaWalletCallbacks:n,setSolanaRecoveryFlowState:o,opts:m})}),[e,n]),v=fe(()=>u(void 0,null,function*(){if(!a)throw new H({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{entropyId:m,entropyIdVerifier:f}=a;return Le({client:e,account:c[0],entropyId:m,entropyIdVerifier:f,setSolanaWallet:r,recoverSolanaWalletCallbacks:d,setSolanaRecoveryFlowState:o})}),[e,a,c,d,o,r]),S=fe(()=>u(void 0,null,function*(){if(!a)throw r({status:"not-created"}),new H({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});r(m=>m.status==="connected"?{status:"reconnecting"}:{status:"connecting"});try{let{entropyId:m,entropyIdVerifier:f}=a,l=yield e.embeddedWallet.getSolanaProvider(c[0],m,f);return r({status:"connected",publicKey:c[0].public_key}),l}catch(m){throw Wt(m)?(r({status:"needs-recovery"}),new H({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):m instanceof Error?(r({status:"error",error:m.message}),new H({code:"unknown_embedded_wallet_error",error:m.message})):(r({status:"error",error:"Error loading embedded wallet"}),new H({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[c,e,a,r]);return Ne(()=>{if(!i&&t.status!=="disconnected")return r({status:"disconnected"});s&&S().catch(()=>{})},[s,i]),Ne(()=>{t.status==="error"&&t.error.includes("User must be logged in")&&S()},[t.status]),{create:w,recover:v,getProvider:S,wallets:p}};import{useCallback as Y,useEffect as He,useMemo as Kt}from"react";import{getUserEmbeddedEthereumWallet as Vt,getUserEmbeddedSolanaWallet as Ge,isUnifiedWallet as qt,throwIfInvalidRecoveryUpgradePath as zt}from"@privy-io/js-sdk-core";import{errorIndicatesRecoveryIsNeeded as Jt,PrivyClientError as C}from"@privy-io/js-sdk-core";import{getUserEmbeddedEthereumWallet as It}from"@privy-io/js-sdk-core";import{PrivyClientError as D}from"@privy-io/js-sdk-core";function oe(w){return u(this,arguments,function*({client:e,setWallet:t,createWalletCallbacks:r,recoveryMethod:o,setRecoveryFlowState:n,password:d,recoveryKey:i,recoveryToken:c,recoverySecretOverride:s,iCloudRecordNameOverride:a,solanaAccount:p}){var S,m;switch(o){case"user-passcode":if(!d)throw new D({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"recovery-encryption-key":if(!i)throw new D({code:"embedded_wallet_recovery_error",error:"key is required for recovery-encryption-key recovery method"});break;case"google-drive":if(!c)throw new D({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!s||!a)throw new D({code:"embedded_wallet_recovery_error",error:"iCloud recovery failed due to inability to store credentials"});break}t({status:"creating",account:null});let v=o==="icloud"?"icloud-native":o;try{let{user:f}=yield e.embeddedWallet.create({password:d,recoveryMethod:v,recoveryKey:i,recoveryToken:c,recoverySecretOverride:s,iCloudRecordNameOverride:a,solanaAccount:p}),l=It(f);if(!l)throw new D({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});let b=yield e.embeddedWallet.getProvider(l);return(m=(S=r.current)==null?void 0:S.onSuccess)==null||m.call(S,b),t({status:"connected",provider:b,account:l}),n({status:"initial"}),b}catch(f){let l=f instanceof Error?f.message:"Error creating embedded wallet";throw t({status:"error",error:l,account:null}),n({status:"initial"}),new D({code:"embedded_wallet_creation_error",error:l})}})}import{Platform as Ke}from"react-native";import{PrivyClientError as W}from"@privy-io/js-sdk-core";function Ve(){return u(this,null,function*(){try{return yield import("@privy-io/expo-native-extensions")}catch(e){throw new Error("@privy-io/expo-native-extensions not found. Ensure that you're explicitly including as a dependency, and running an Expo development build")}})}function we(o){return u(this,arguments,function*({user:e,appId:t,client:r}){var c;if(Ke.OS==="android")throw new W({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let n=yield Ve(),d=yield r.recovery.icloudAuth.getICloudConfiguration("expo-ios");if(!(d==null?void 0:d.container_identifier))throw new W({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:s,iCloudRecordName:a}=yield n.writeRecoverySecretToICloud({containerId:d.container_identifier,appId:t,userId:e.id});return{recoverySecret:s,iCloudRecordName:a}}catch(s){if(s instanceof Error){let a=(c=s.message.split("Caused by: ")[1])!=null?c:"Error writing to iCloud";throw new W({code:"embedded_wallet_recovery_error",error:a})}throw new W({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}function qe(o){return u(this,arguments,function*({walletAddress:e,client:t,chainType:r}){var a;if(Ke.OS==="android")throw new W({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let n=yield Ve(),i=(yield t.recovery.getRecoveryKeyMaterial(e,r)).icloud_record_name;if(!i)throw new W({code:"embedded_wallet_recovery_error",error:"iCloud recovery not properly backed up."});let c=yield t.recovery.icloudAuth.getICloudConfiguration("expo-ios"),s=c==null?void 0:c.container_identifier;if(!s)throw new W({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:p}=yield n.readRecoverySecretFromICloud({containerId:s,recordName:i});return{recoverySecret:p}}catch(p){if(p instanceof Error){let w=(a=p.message.split("Caused by: ")[1])!=null?a:"Error writing to iCloud";throw new W({code:"embedded_wallet_recovery_error",error:w})}throw new W({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}import*as L from"expo-linking";import*as ze from"expo-web-browser";import{Platform as Je}from"react-native";import{PrivyClientError as V}from"@privy-io/js-sdk-core";import yo from"react-fast-compare";import{PrivyApiError as Ut,PrivyClientError as Tt}from"@privy-io/js-sdk-core";function K(e){return e instanceof Error||e instanceof Ut||e instanceof Tt?e:typeof e=="string"?new Error(e):new Error("Unknown error")}var bo=e=>new Promise(t=>setTimeout(t,e));import{useEffect as Ft,useRef as Mt}from"react";import{AppState as Se}from"react-native";function _o(){let e=Mt(Se.currentState);Ft(()=>Se.addEventListener("change",o=>{e.current=o}).remove,[]);function t(){return Se.currentState}return{appState:e,getCurrentAppState:t}}function G(n){return u(this,arguments,function*({provider:e,redirectUri:t,client:r,onError:o}){try{let d;switch(e){case"google-drive":{let{url:a}=yield r.recovery.auth.generateURL(L.createURL(t||"/"));d=a;break}default:throw new V({error:"OAuth invalid provider",code:"embedded_wallet_recovery_error"})}let i=yield ze.openAuthSessionAsync(d);if(Je.OS==="android")return;if(i.type!=="success")throw new V({error:"Recovery OAuth session failed",code:"embedded_wallet_recovery_error"});let{queryParams:c}=L.parse(i.url),s;switch(e){case"google-drive":{let{privy_oauth_state:a,privy_oauth_code:p}=c;if(!p||!a)throw new V({error:"Recovery OAuth invalid credentials",code:"embedded_wallet_recovery_error"});s=yield ae({oAuthCode:p,oAuthState:a,client:r});break}default:throw new V({error:"Recovery OAuth invalid provider",code:"embedded_wallet_recovery_error"})}return s}catch(d){throw o==null||o(K(d)),d}})}function ae(o){return u(this,arguments,function*({oAuthCode:e,oAuthState:t,client:r}){let{access_token:n}=yield r.recovery.auth.authorize(e,t);if(!n)throw new V({error:"OAuth invalid credentials",code:"login_with_oauth_returned_with_invalid_credentials"});return n})}var Lt=2*60*1e3;function Nt(e){let t;return new Promise((r,o)=>{t=L.addEventListener("url",d=>u(this,[d],function*({url:n}){if(!n)return;let{queryParams:i}=L.parse(n),{privy_oauth_state:c,privy_oauth_code:s}=i!=null?i:{};if(typeof s!="string"||typeof c!="string")return;let a=yield ae({client:e,oAuthCode:s,oAuthState:c});r(a)})),setTimeout(()=>{o(new V({code:"embedded_wallet_set_recovery_error",error:"Failed to complete Google Drive recovery flow"}))},Lt)}).finally(()=>{t==null||t.remove()})}function Uo(e){return u(this,null,function*(){let t;Je.OS==="android"&&(t=Nt(e));let r=yield G({provider:"google-drive",client:e});return r!=null?r:yield t})}import{getUserEmbeddedWallet as jt,PrivyClientError as Dt}from"@privy-io/js-sdk-core";function ne(d){return u(this,arguments,function*({client:e,recoveryInput:t,setWalletRecoveryCallbacks:r,setRecoveryFlowState:o,setWallet:n}){var i,c,s,a;try{let{provider:p,user:w}=yield e.embeddedWallet.setRecovery(t),v=p,S=jt(w);return n({status:"connected",provider:v,account:S}),(c=(i=r.current)==null?void 0:i.onSuccess)==null||c.call(i,v),o({status:"initial"}),v}catch(p){let w=new Dt({code:"embedded_wallet_set_recovery_error",error:p instanceof Error?p.message:"Error setting password on embedded wallet"});throw(a=(s=r.current)==null?void 0:s.onError)==null||a.call(s,w),o({status:"initial"}),w}})}function Ye(e){return e===void 0?{recoveryMethod:"privy"}:typeof e=="string"?{recoveryMethod:"user-passcode",password:e}:e.recoveryMethod==="user-passcode"?{recoveryMethod:"user-passcode",password:e.password}:e.recoveryMethod==="recovery-encryption-key"?{recoveryMethod:"recovery-encryption-key",recoveryKey:e.recoveryKey}:{recoveryMethod:e.recoveryMethod}}var Be=({client:e,appId:t,wallet:r,setWallet:o,setRecoveryFlowState:n,createWalletCallbacks:d,recoverWalletCallbacks:i,setWalletRecoveryCallbacks:c})=>{let s=U(),a=Kt(()=>Vt(s),[s]),p=T(),w=Y(l=>u(void 0,null,function*(){var X,$;if(a)throw new C({error:"This user already has an embedded wallet",code:"embedded_wallet_already_exists"});let{user:b}=yield e.user.get(),{password:y,recoveryMethod:h,recoveryKey:g}=Ye(l),_,E,N;if(h==="google-drive"&&(_=yield G({provider:h,client:e,onError:(X=d.current)==null?void 0:X.onError}),n({status:"creating-wallet"}),!_))return null;if(h==="icloud"){if(!b)throw new C({code:"embedded_wallet_recovery_error",error:"User must be loaded before creating a wallet with iCloud."});let{recoverySecret:se,iCloudRecordName:de}=yield we({user:b,appId:t,client:e});E=se,N=de}return yield oe({client:e,setWallet:o,createWalletCallbacks:d,recoveryMethod:h,recoveryKey:g,setRecoveryFlowState:n,password:y,recoverySecretOverride:E,iCloudRecordNameOverride:N,solanaAccount:($=Ge(b))!=null?$:void 0})}),[e,a,s]),v=Y(l=>u(void 0,null,function*(){var h;if(r.status!=="connected")throw new C({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"});if(!a)throw new C({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(Ge(s))throw new C({code:"embedded_wallet_set_recovery_error",error:"Cannot set user-controlled recovery for a user with an embedded Solana wallet."});if(qt(a))throw new C({code:"unsupported_wallet_type",error:"Embedded wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});zt({currentRecoveryMethod:a.recovery_method,upgradeToRecoveryMethod:l.recoveryMethod});let b,y;switch(l.recoveryMethod){case"privy":y=F(P({},l),{wallet:a});break;case"user-passcode":y=F(P({},l),{wallet:a,password:l.password});break;case"google-drive":if(b=yield G({provider:l.recoveryMethod,client:e,onError:(h=c.current)==null?void 0:h.onError}),n({status:"upgrading-recovery"}),!b)return null;y={recoveryMethod:"google-drive",wallet:a,recoveryAccessToken:b};break;case"icloud":if(!s)throw new C({code:"embedded_wallet_recovery_error",error:"User must be loaded before backing up to iCloud."});let{recoverySecret:g,iCloudRecordName:_}=yield we({user:s,appId:t,client:e});y={recoveryMethod:"icloud-native",recoverySecretOverride:g,iCloudRecordNameOverride:_,wallet:a};break;default:throw new C({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}return ne({client:e,recoveryInput:y,setWalletRecoveryCallbacks:c,setRecoveryFlowState:n,setWallet:o})}),[e,a,r.status,s]),S=Y(l=>u(void 0,null,function*(){return v({recoveryMethod:"user-passcode",password:l})}),[e,a,r.status]),m=Y(l=>u(void 0,null,function*(){var E;if(!a)throw new C({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{password:b,recoveryMethod:y,recoveryKey:h}=Ye(l),g,_;if(y==="google-drive"&&(g=yield G({provider:y,client:e,onError:(E=i.current)==null?void 0:E.onError}),n({status:"recovering"}),!g))return null;if(y==="icloud"){if(!s)throw new C({code:"embedded_wallet_recovery_error",error:"User must be loaded before recovering via iCloud."});let{recoverySecret:N}=yield qe({client:e,walletAddress:a.address});_=N}return re({client:e,account:a,setWallet:o,recoverWalletCallbacks:i,recoveryMethod:y,setRecoveryFlowState:n,recoveryKey:h,password:b,recoveryToken:g,recoverySecretOverride:_})}),[e,a]),f=Y(()=>u(void 0,null,function*(){if(!a)throw o({status:"not-created",account:null}),new C({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});o(l=>l.status==="connected"?{status:"reconnecting",account:a}:{status:"connecting",account:a});try{let l=yield e.embeddedWallet.getProvider(a);return o({status:"connected",provider:l,account:a}),l}catch(l){throw Jt(l)?(o({status:"needs-recovery",account:a}),new C({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):l instanceof Error?(o({status:"error",error:l.message,account:a}),new C({code:"unknown_embedded_wallet_error",error:l.message})):(o({status:"error",error:"Error loading embedded wallet",account:a}),new C({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,a]);return He(()=>{if(!s&&r.status!=="disconnected")return o({status:"disconnected",account:null});p&&f().catch(()=>{})},[p,s,a]),He(()=>{r.status==="error"&&r.error.includes("User must be logged in")&&f()},[r.status]),{create:w,recover:m,setPassword:S,setRecovery:v,getProvider:f}};import{useEffect as Ht,useState as Gt}from"react";import{PrivyClientError as Xe}from"@privy-io/js-sdk-core";var $e=({client:e,isReady:t})=>{let r=U(),o=ee(i=>i==null?void 0:i.customAuth),[n,d]=Gt({status:"initial"});return Ht(()=>{(()=>u(void 0,null,function*(){if(!(o!=null&&o.enabled)){d({status:"not-enabled"});return}d({status:"loading"});let{getCustomAccessToken:c,isLoading:s}=o;if(!(!t||s))try{let a=yield c();if(!a&&r){yield e.auth.logout(),d({status:"done"});return}if(!a){d({status:"done"});return}if(r){d({status:"done"});return}let p=Oe();if(!(yield e.auth.customProvider.syncWithToken(a,{embedded:p==null?void 0:p.embedded}))){yield e.auth.logout(),d({status:"error",error:new Xe({error:"Failed to sync with custom auth provider",code:"third_party_auth_error"})});return}d({status:"done"})}catch(a){if(console.log("Error syncing with custom auth provider",a),d({status:"error",error:a}),r)throw yield e.auth.logout(),new Xe({error:"Third-party auth failed",code:"third_party_auth_error"})}}))()},[e,r,t,o==null?void 0:o.enabled,o==null?void 0:o.getCustomAccessToken,o==null?void 0:o.isLoading]),{customAuthState:n,customAuthStateIsSettled:n.status!=="loading"&&n.status!=="initial"}};import*as q from"expo-linking";import{useCallback as Yt,useEffect as Bt,useMemo as Xt}from"react";import{Platform as $t}from"react-native";import{getUserEmbeddedSolanaWallet as Qt,getUserEmbeddedWallet as Zt}from"@privy-io/js-sdk-core";var Qe=({client:e,createWalletCallbacks:t,recoverWalletCallbacks:r,setWalletRecoveryCallbacks:o,recoveryFlowState:n,oAuthState:d,setRecoveryFlowState:i,setWallet:c,appStateVisible:s})=>{let a=q.useURL(),p=U(),w=Xt(()=>Zt(p),[p]),v=T(),S=Yt(m=>{var l,b,y,h;let f=K(m);n.status==="creating-wallet"?(b=(l=t.current).onError)==null||b.call(l,K(f)):(h=(y=r.current).onError)==null||h.call(y,K(f)),i({status:"initial"})},[n]);return Bt(()=>{function m(){return u(this,null,function*(){var y;if(!a&&n.status!=="initial"&&s&&S(new Error("Recovery OAuth session failed")),!a||n.status==="initial"||d.status!=="initial"||!s||!v)return;let{queryParams:f}=q.parse(a),{privy_oauth_state:l,privy_oauth_code:b}=f;if(!(!b||!l)){yield q.openURL(a.split("?")[0]);try{let h=yield ae({oAuthCode:b,oAuthState:l,client:e});if(n.status==="creating-wallet"){let g=(y=Qt(p))!=null?y:void 0;yield oe({client:e,setWallet:c,createWalletCallbacks:t,recoveryMethod:"google-drive",setRecoveryFlowState:i,recoveryToken:h,solanaAccount:g})}else if(n.status==="upgrading-recovery"){if(!w)throw new Error("Embedded wallet not found");yield ne({client:e,recoveryInput:{recoveryMethod:"google-drive",wallet:w,recoveryAccessToken:h},setWalletRecoveryCallbacks:o,setRecoveryFlowState:i,setWallet:c})}else yield re({client:e,account:w,setWallet:c,recoverWalletCallbacks:r,recoveryMethod:"google-drive",setRecoveryFlowState:i,recoveryToken:h})}catch(h){S(h)}}})}$t.OS==="android"&&m()},[a,n.status,s,v])};import{useEffect as er}from"react";var Ze=({client:e,isUserInitialized:t,setIsUserInitialized:r,setError:o})=>{er(()=>{t||(()=>u(void 0,null,function*(){try{yield e.initialize()}catch(d){o(d instanceof Error?d:new Error(String(d)))}try{yield e.user.get()}catch(d){}finally{r(!0)}}))()},[e,t,o,r])};var ot=rr(null),J;function xa(e){return J?J.getAccessToken():e!=null&&e.strict?Promise.reject(new rt({code:"attempted_to_read_storage_before_client_initialized",error:"Called `getAccessToken` before client initialized"})):(console.warn("Called `getAccessToken` before client initialized"),Promise.resolve(null))}var Wa=e=>{nr();let[t,r]=k(tt.currentState==="active");et(()=>{let O=tt.addEventListener("change",ut=>{r(ut==="active")});return()=>{O.remove()}},[]),et(()=>We(e.config),[e.config]);let[o,n]=k(!1),[d,i]=k(null),[c,s]=k(!1),[a,p]=k({status:"disconnected",account:null}),[w,v]=k({status:"disconnected"}),[S,m]=k({status:"initial"}),[f,l]=k({status:"initial"}),[b,y]=k({status:"initial"}),[h,g]=k({status:"initial"}),[_,E]=k({status:"initial"}),[N,X]=k({status:"initial"}),[$,se]=k({status:"initial"}),de=z({}),ce=z({}),le=z({}),ue=z({}),ge=z({}),_e=z({}),Q=ie(O=>{if(O){me(O),i(null);return}me(null),m({status:"initial"}),l({status:"initial"}),p({status:"disconnected",account:null})},[]),R=tr(()=>{let O=e.storage||Z;return e.client?J=e.client:J=xe({appId:e.appId,clientId:e.clientId,supportedChains:e.supportedChains,storage:O,baseUrl:e.baseUrl,logLevel:e.logLevel}),J.setCallbacks({setUser:Q,setIsReady:s}),J},[e.client,e.storage,e.appId,e.clientId,e.baseUrl,e.supportedChains,e.logLevel,Q]),at=ie(()=>(Q(null),R.auth.logout()),[Q,R]),nt=ie(()=>u(void 0,null,function*(){try{return yield R.getAccessToken()}catch(O){return console.debug(O),null}}),[R]),it=ie(()=>R.getIdentityToken(),[R]);Ze({client:R,isUserInitialized:o,setIsUserInitialized:n,setError:i});let st=Be({client:R,appId:e.appId,createWalletCallbacks:ce,recoverWalletCallbacks:le,setWalletRecoveryCallbacks:ue,setRecoveryFlowState:y,wallet:a,setWallet:p}),dt=De({client:R,createSolanaWalletCallbacks:ge,recoverSolanaWalletCallbacks:_e,setSolanaRecoveryFlowState:g,solanaWallet:w,setSolanaWallet:v});Qe({client:R,createWalletCallbacks:ce,recoverWalletCallbacks:le,setWalletRecoveryCallbacks:ue,recoveryFlowState:b,oAuthState:f,setRecoveryFlowState:y,setWallet:p,appStateVisible:t});let{customAuthStateIsSettled:ct}=$e({client:R,isReady:o}),lt=T();return B.createElement(B.Fragment,null,B.createElement(ot.Provider,{value:{client:R,isReady:lt&&o&&ct,error:d,logout:at,getAccessToken:nt,getIdentityToken:it,wallet:P(P({},a),st),solanaWallet:P(P({},w),dt),oAuthState:f,oAuthCallbacks:de,recoveryFlowState:b,setRecoveryFlowState:y,solanaRecoveryFlowState:h,setSolanaRecoveryFlowState:g,createWalletCallbacks:ce,recoverWalletCallbacks:le,setWalletRecoveryCallbacks:ue,createSolanaWalletCallbacks:ge,recoverSolanaWalletCallbacks:_e,setOAuthState:l,siweState:_,setSiweState:E,otpState:S,setOtpState:m,passkeyState:N,setPasskeyState:X,farcasterState:$,setFarcasterState:se}},e.children),B.createElement(ar,{style:{width:0,height:0,overflow:"hidden"}},B.createElement(Te,{client:R,isClientReady:c})))},nr=()=>{if(or(ot))throw new rt({code:"configuration_error",error:"Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree."})};import{PrivyClientError as ir}from"@privy-io/js-sdk-core";var sr=e=>u(void 0,null,function*(){var o;let r=yield(yield import("react-native-passkeys")).create({rp:e.rp,user:e.user,challenge:e.challenge,pubKeyCredParams:e.pubKeyCredParams,excludeCredentials:e.excludeCredentials,authenticatorSelection:e.authenticatorSelection,timeout:12e4});if(!r)throw new ir({code:"failed_to_create_passkey",error:"Could not create passkey"});return F(P({},r),{type:(o=r.type)!=null?o:"public-key",clientExtensionResults:{}})});import{PrivyClientError as dr}from"@privy-io/js-sdk-core";var cr=e=>u(void 0,null,function*(){var o;let r=yield(yield import("react-native-passkeys")).get({rpId:e.rpId,challenge:e.challenge,allowCredentials:e.allowCredentials,timeout:12e4});if(!r)throw new dr({code:"no_passkey_found_for_challenge",error:"Could not find a matching passkey to login with"});return F(P({},r),{type:(o=r.type)!=null?o:"public-key",clientExtensionResults:{}})});function za(e){var t;return{id:e.id,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},raw_id:e.rawId,type:e.type,authenticator_attachment:(t=e.authenticatorAttachment)!=null?t:"platform",response:{authenticator_data:e.response.authenticatorData,client_data_json:e.response.clientDataJSON,signature:e.response.signature,user_handle:e.response.userHandle}}}function Ja(e){var t,r,o,n;return{challenge:e.challenge,rpId:e.rp_id,extensions:{appid:(t=e.extensions)==null?void 0:t.app_id,credProps:(r=e.extensions)==null?void 0:r.cred_props,hmacCreateSecret:(o=e.extensions)==null?void 0:o.hmac_create_secret},timeout:e.timeout,allowCredentials:(n=e.allow_credentials)==null?void 0:n.map(({id:d,type:i,transports:c})=>({id:d,type:i,transports:c})),userVerification:e.user_verification}}function Ha(e){var t,r,o,n,d,i,c,s;return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params,extensions:{hmacCreateSecret:(t=e.extensions)==null?void 0:t.hmac_create_secret,credProps:(o=(r=e.extensions)==null?void 0:r.cred_props)==null?void 0:o.rk,appid:(n=e.extensions)==null?void 0:n.app_id},attestation:e.attestation,excludeCredentials:e.exclude_credentials,authenticatorSelection:{authenticatorAttachment:(d=e.authenticator_selection)==null?void 0:d.authenticator_attachment,residentKey:(i=e.authenticator_selection)==null?void 0:i.resident_key,userVerification:(c=e.authenticator_selection)==null?void 0:c.user_verification,requireResidentKey:(s=e.authenticator_selection)==null?void 0:s.require_resident_key}}}export{Oe as a,Or as b,Ir as c,U as d,Ur as e,Ce as f,pr as g,we as h,qe as i,K as j,bo as k,_o as l,Uo as m,Z as n,xe as o,ot as p,xa as q,Wa as r,sr as s,cr as t,za as u,Ja as v,Ha as w};
