import{a as K,b as C,d as k}from"./chunk-OWCFWPAL.js";import{base58 as l}from"@scure/base";import*as i from"expo-linking";import*as x from"expo-secure-store";import{useState as z,useEffect as Q,useRef as $,useCallback as F}from"react";import v from"tweetnacl";var P=(s,p,c)=>`${s}/ul/v1/${p}?${c.toString()}`,b=(s,p)=>{if(!p)throw new Error("missing shared secret");let c=v.randomBytes(24),a=v.box.after(Buffer.from(JSON.stringify(s)),c,p);return{nonce:l.encode(c),data:l.encode(a)}},U=(s,p,c)=>{if(!c)throw new Error("missing shared secret");let a=v.box.open.after(l.decode(s),l.decode(p),c);if(!a)throw new Error("Unable to decrypt data");return JSON.parse(Buffer.from(a).toString("utf8"))},V=s=>JSON.stringify({publicKey:Array.from(s.publicKey),secretKey:Array.from(s.secretKey)}),X=s=>{let p=JSON.parse(s);return{publicKey:new Uint8Array(p.publicKey),secretKey:new Uint8Array(p.secretKey)}},B="wallet_keypair",q=6e4,D=({baseUrl:s,appUrl:p,redirectUri:c="/",encryptionPublicKeyName:a})=>{if(!s||!p||!c||!a)throw new Error("baseUrl, appUrl, redirectUri, and encryptionPublicKeyName are required");let[L,M]=z(!1),[u,j]=z(null),n=$(null),m=$(null),E=$(null),_=F(()=>k(void 0,null,function*(){if(E.current)return E.current;try{let o=yield x.getItemAsync(B);if(o){let r=X(o);return E.current=r,r}else{let r=v.box.keyPair();return E.current=r,yield x.setItemAsync(B,V(r)),r}}catch(o){throw console.error("Failed to initialize key pair:",o),o}}),[]),W=F(o=>k(void 0,null,function*(){var g;if(!o)return;let e=new URL(o).searchParams,d=e.get("wallet_id");if(!d||d!==a)return;if(e.get("errorCode")){let t=Object.fromEntries([...e]),y=(g=t==null?void 0:t.errorMessage)!=null?g:JSON.stringify(Object.fromEntries([...e]),null,2);console.error("Error from wallet provider: ",y);return}switch(e.get("wallet_action")){case"onConnect":try{if(!e.get("data")||!e.get("nonce")||!e.get(a))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=yield _(),y=v.box.before(l.decode(e.get(a)),t.secretKey),f=U(e.get("data"),e.get("nonce"),y);m.current=y,j(f),M(!0)}catch(t){console.error("Failed to process connect response:",t)}break;case"onSignMessage":try{if(!n.current||n.current.type!=="signMessage"){console.warn("Received signature response but no pending signature request");return}if(!e.get("data")||!e.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(e.get("data"),e.get("nonce"),m.current);n.current.resolve(t),n.current=null}catch(t){console.error("Failed to process signature response:",t),n.current&&(n.current.reject(t),n.current=null)}break;case"onSignTransaction":try{if(!n.current||n.current.type!=="signTransaction"){console.warn("Received signature response but no pending signature request");return}if(!e.get("data")||!e.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(e.get("data"),e.get("nonce"),m.current);n.current.resolve(t),n.current=null}catch(t){console.error("Failed to process transaction response:",t),n.current&&(n.current.reject(t),n.current=null)}break;case"onSignAndSendTransaction":try{if(!n.current||n.current.type!=="signAndSendTransaction"){console.warn("Received signature response but no pending signature request");return}if(!e.get("data")||!e.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(e.get("data"),e.get("nonce"),m.current);n.current.resolve(t),n.current=null}catch(t){console.error("Failed to process transaction response:",t),n.current&&(n.current.reject(t),n.current=null)}break;case"onSignAllTransactions":try{if(!n.current||n.current.type!=="signAllTransactions"){console.warn("Received signature response but no pending signature request");return}if(!e.get("data")||!e.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(e.get("data"),e.get("nonce"),m.current);n.current.resolve(t),n.current=null}catch(t){console.error("Failed to process transaction response:",t),n.current&&(n.current.reject(t),n.current=null)}break;case"onDisconnect":M(!1),j(null);break}}),[_,a]);Q(()=>{(()=>k(void 0,null,function*(){let e=yield i.getInitialURL();e&&W(e)}))();let r=i.addEventListener("url",({url:e})=>W(e));return()=>{r.remove()}},[a,W]);let I=()=>k(void 0,null,function*(){try{let o=yield _();if(!o)throw new Error("No dapp key pair found");let r={session:u==null?void 0:u.session},{nonce:e,data:d}=b(r,m.current),w=new URLSearchParams({nonce:e,dapp_encryption_public_key:l.encode(o.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onDisconnect&wallet_id=${a}`,payload:d}),g=P(s,"disconnect",w);yield i.openURL(g)}catch(o){throw console.error("Failed to disconnect:",o),o}}),N=o=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let r=yield _();if(!r)throw new Error("No dapp key pair found");let e={session:u.session,message:l.encode(Buffer.from(o)),display:"utf8"},{nonce:d,data:w}=b(e,m.current),g=new URLSearchParams({dapp_encryption_public_key:l.encode(r.publicKey),nonce:d,payload:w,redirect_link:`${i.createURL(c)}?wallet_action=onSignMessage&wallet_id=${a}`}),t=P(s,"signMessage",g);return new Promise((y,f)=>{i.openURL(t);let T=setTimeout(()=>{n.current&&(f(new Error("Signature request timed out")),n.current=null)},q),S=h=>{clearTimeout(T),y(h)},A=h=>{clearTimeout(T),f(h)};n.current={type:"signMessage",payload:o,resolve:S,reject:A}})}catch(r){throw n.current=null,console.error("Failed to sign message:",r),r}}),J=(o,r)=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let e=yield _();if(!e)throw new Error("No dapp key pair found");let d=o.serialize({requireAllSignatures:!1}),w={session:u.session,transaction:l.encode(d),sendOptions:r},{nonce:g,data:t}=b(w,m.current),y=new URLSearchParams({nonce:g,dapp_encryption_public_key:l.encode(e.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onSignAndSendTransaction&wallet_id=${a}`,payload:t}),f=P(s,"signAndSendTransaction",y);return new Promise((T,S)=>{i.openURL(f);let A=setTimeout(()=>{n.current&&(S(new Error("Signature request timed out")),n.current=null)},q),h=O=>{clearTimeout(A),T(O)},R=O=>{clearTimeout(A),S(O)};n.current={type:"signAndSendTransaction",payload:o,resolve:h,reject:R}})}catch(e){throw n.current=null,console.error("Failed to sign and send transaction:",e),e}}),Y=o=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let r=yield _();if(!r)throw new Error("No dapp key pair found");let d={transactions:o.map(f=>l.encode(f.serialize({requireAllSignatures:!1}))),session:u.session},{nonce:w,data:g}=b(d,m.current),t=new URLSearchParams({nonce:w,dapp_encryption_public_key:l.encode(r.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onSignAllTransactions&wallet_id=${a}`,payload:g}),y=P(s,"signAllTransactions",t);return new Promise((f,T)=>{i.openURL(y);let S=setTimeout(()=>{n.current&&(T(new Error("Signature request timed out")),n.current=null)},q),A=R=>{clearTimeout(S),f(R)},h=R=>{clearTimeout(S),T(R)};n.current={type:"signAllTransactions",payload:o,resolve:A,reject:h}})}catch(r){throw n.current=null,console.error("Failed to sign all transactions:",r),r}}),G=o=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let r=yield _();if(!r)throw new Error("No dapp key pair found");let e=o.serialize({requireAllSignatures:!1}),d={session:u.session,transaction:l.encode(e)},{nonce:w,data:g}=b(d,m.current),t=new URLSearchParams({nonce:w,dapp_encryption_public_key:l.encode(r.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onSignTransaction&wallet_id=${a}`,payload:g}),y=P(s,"signTransaction",t);return new Promise((f,T)=>{i.openURL(y);let S=setTimeout(()=>{n.current&&(T(new Error("Signature request timed out")),n.current=null)},q),A=R=>{clearTimeout(S),f(R)},h=R=>{clearTimeout(S),T(R)};n.current={type:"signTransaction",payload:o,resolve:A,reject:h}})}catch(r){throw n.current=null,console.error("Failed to sign transaction:",r),r}}),H=()=>k(void 0,null,function*(){let o=yield _();if(!o)throw new Error("No dapp key pair found");try{let r=new URLSearchParams({dapp_encryption_public_key:l.encode(o.publicKey),app_url:p,redirect_link:`${i.createURL(c)}?wallet_action=onConnect&wallet_id=${a}`}),e=P(s,"connect",r);yield i.openURL(e)}catch(r){console.error("Failed to open wallet connection:",r)}});return{address:u==null?void 0:u.public_key,connect:H,signMessage:N,signTransaction:G,signAndSendTransaction:J,signAllTransactions:Y,disconnect:I,isConnected:L}};var se=s=>D(C(K({},s),{baseUrl:"https://phantom.app",encryptionPublicKeyName:"phantom_encryption_public_key"}));var le=s=>D(C(K({},s),{baseUrl:"https://backpack.app",encryptionPublicKeyName:"wallet_encryption_public_key"}));export{le as useBackpackDeeplinkWalletConnector,D as useDeeplinkWalletConnector,se as usePhantomDeeplinkWalletConnector};
