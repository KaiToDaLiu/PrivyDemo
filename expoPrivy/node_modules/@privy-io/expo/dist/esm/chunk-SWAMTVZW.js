import{a as b,b as h,d as x,f as me,h as pe,i as ge,j as f,k as A,l as H,m as B,p as u,t as he,u as fe,v as ye}from"./chunk-WYJVIY4U.js";import{a as _,b as ue,d as l}from"./chunk-OWCFWPAL.js";import{useCallback as q,useContext as $e}from"react";import{PrivyClientError as Je}from"@privy-io/js-sdk-core";var jt=e=>{let{client:t,setSiweState:i,siweState:n}=$e(u),o=q(a=>{var d;let c=f(a);return i({status:"error",error:c}),(d=e==null?void 0:e.onError)==null||d.call(e,c),c},[e==null?void 0:e.onError]),r=q(g=>l(void 0,[g],function*({wallet:a,from:{domain:c,uri:d}}){var m;try{i({status:"generating-message"});let p=yield t.auth.siwe.init(a,c,d);return i({status:"awaiting-signature"}),(m=e==null?void 0:e.onGenerateMessage)==null||m.call(e,p.message),p.message}catch(p){throw o(p)}}),[t,o,e==null?void 0:e.onGenerateMessage]),s=q(d=>l(void 0,[d],function*({signature:a,messageOverride:c}){var g;try{if(!h())throw new Je({code:"attempted_link_siwe_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiwe` to login with a wallet"});i({status:"submitting-signature"});let{user:p}=yield t.auth.siwe.linkWithSiwe(a,void 0,c);return i({status:"done"}),(g=e==null?void 0:e.onSuccess)==null||g.call(e,p),p}catch(m){throw o(m)}}),[t,o,e==null?void 0:e.onSuccess]);return{generateSiweMessage:r,linkWithSiwe:s,state:n}};import{useCallback as $,useContext as Qe}from"react";import{PrivyClientError as Xe}from"@privy-io/js-sdk-core";var eo=e=>{let{client:t,setSiweState:i,siweState:n}=Qe(u),o=$(a=>{var d;let c=f(a);return i({status:"error",error:c}),(d=e==null?void 0:e.onError)==null||d.call(e,c),c},[e==null?void 0:e.onError]),r=$(g=>l(void 0,[g],function*({wallet:a,from:{domain:c,uri:d}}){var m;try{i({status:"generating-message"});let p=yield t.auth.siwe.init(a,c,d);return i({status:"awaiting-signature"}),(m=e==null?void 0:e.onGenerateMessage)==null||m.call(e,p.message),p.message}catch(p){throw o(p)}}),[t,o,e==null?void 0:e.onGenerateMessage]);return{loginWithSiwe:$(g=>l(void 0,[g],function*({signature:a,messageOverride:c,disableSignup:d}){var m;try{if(h())throw new Xe({code:"attempted_login_with_siwe_while_already_logged_in",error:"Already logged in, use `useLinkWithSiwe` if you are trying to link a wallet to an existing account"});i({status:"submitting-signature"});let v=b(),y=yield t.auth.siwe.loginWithSiwe(a,void 0,c,d?"no-signup":"login-or-sign-up",{embedded:v==null?void 0:v.embedded});return i({status:"done"}),(m=e==null?void 0:e.onSuccess)==null||m.call(e,y.user,y.is_new_user),y.user}catch(p){throw o(p)}}),[t,o,e==null?void 0:e.onSuccess]),generateSiweMessage:r,state:n}};import{useContext as Ye}from"react";var C=()=>{let{client:e}=Ye(u);return e};import{useCallback as we}from"react";import{createSiwsMessage as Ze,PrivyClientError as er}from"@privy-io/js-sdk-core";var mo=()=>{let e=C(),t=we(s=>l(void 0,[s],function*({wallet:{address:n},from:{domain:o,uri:r}}){try{let{nonce:a}=yield e.auth.siws.fetchNonce({address:n});return{message:Ze({address:n,domain:o,uri:r,nonce:a})}}catch(a){throw f(a)}}),[e]),i=we(a=>l(void 0,[a],function*({signature:n,message:o,wallet:{walletClientType:r,connectorType:s}={}}){try{if(!h())throw new er({code:"attempted_link_siws_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiws` to login with a wallet"});let{user:d}=yield e.auth.siws.link({signature:n,message:o,walletClientType:r,connectorType:s});return d}catch(c){throw f(c)}}),[e]);return{generateMessage:t,link:i}};import{useCallback as ve}from"react";import{createSiwsMessage as rr,PrivyClientError as tr}from"@privy-io/js-sdk-core";var So=()=>{let e=C(),t=ve(s=>l(void 0,[s],function*({wallet:{address:n},from:{domain:o,uri:r}}){try{let{nonce:a}=yield e.auth.siws.fetchNonce({address:n});return{message:rr({address:n,domain:o,uri:r,nonce:a})}}catch(a){throw f(a)}}),[e]),i=ve(c=>l(void 0,[c],function*({signature:n,message:o,wallet:{walletClientType:r,connectorType:s}={},disableSignup:a}){try{if(h())throw new tr({code:"attempted_login_with_siws_while_already_logged_in",error:"Already logged in, use `useLinkWithSiws` if you are trying to link a wallet to an existing account"});return(yield e.auth.siws.login({signature:n,message:o,walletClientType:r,connectorType:s,mode:a?"no-signup":"login-or-sign-up"})).user}catch(d){throw f(d)}}),[e]);return{generateMessage:t,login:i}};import{useCallback as Se,useContext as or}from"react";import{PrivyClientError as nr}from"@privy-io/js-sdk-core";var _o=e=>{let{client:t}=or(u),i=Se(o=>{var s;let r=f(o);return(s=e==null?void 0:e.onError)==null||s.call(e,r),r},[e==null?void 0:e.onError]);return{unlinkWallet:Se(r=>l(void 0,[r],function*({address:o}){var s;try{if(!h())throw new nr({code:"attempted_unlink_siwe_before_logged_in",error:"Must be logged in to unlink a wallet, Use `useLoginWithSiwe` to login with a wallet"});let{user:c}=yield t.auth.siwe.unlinkWallet(o);return(s=e==null?void 0:e.onSuccess)==null||s.call(e,c),c}catch(a){throw i(a)}}),[t,i,e==null?void 0:e.onSuccess])}};import{useCallback as J,useContext as ir,useState as sr}from"react";import{PrivyClientError as ke}from"@privy-io/js-sdk-core";var Fo=e=>{let[t,i]=sr(""),{client:n,otpState:o,setOtpState:r}=ir(u),s=J(d=>{var m;let g=f(d);return r({status:"error",error:g}),(m=e==null?void 0:e.onError)==null||m.call(e,g),g},[e,r]),a=J(g=>l(void 0,[g],function*({email:d}){var m;i(d);try{r({status:"sending-code"});let p=yield n.auth.email.sendCode(d);return r({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{email:d}),p}catch(p){throw s(p)}}),[n,s,e,r]),c=J(m=>l(void 0,[m],function*({code:d,email:g}){var p;try{if(!h())throw new ke({code:"attempted_link_email_before_logged_in",error:"Must be logged in to link an email, Use `useLoginWithEmail` to login with email"});let y=g||t;if(!y)throw new ke({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `linkWithCode`"});r({status:"submitting-code"});let{user:S}=yield n.auth.email.linkWithCode(y,d);return r({status:"done"}),(p=e==null?void 0:e.onLinkSuccess)==null||p.call(e,S),S}catch(v){throw s(v)}}),[t,r,n,e,s]);return{sendCode:a,linkWithCode:c,state:o}};import{useCallback as Q,useContext as ar,useState as cr}from"react";import{PrivyClientError as be}from"@privy-io/js-sdk-core";var jo=e=>{let[t,i]=cr(""),{client:n,otpState:o,setOtpState:r}=ar(u),s=Q(d=>{var m;let g=f(d);return r({status:"error",error:g}),(m=e==null?void 0:e.onError)==null||m.call(e,g),g},[e,r]),a=Q(g=>l(void 0,[g],function*({email:d}){var m;i(d);try{r({status:"sending-code"});let p=yield n.auth.email.sendCode(d);return r({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{email:d}),p}catch(p){throw s(p)}}),[n,s,e,r]),c=Q(p=>l(void 0,[p],function*({code:d,email:g,disableSignup:m}){var v;try{if(h())throw new be({code:"attempted_login_with_email_while_already_logged_in",error:"Already logged in, use `useLinkWithEmail` if you are trying to link an email to an existing account"});let S=g||t;if(!S)throw new be({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `loginWithCode`"});r({status:"submitting-code"});let k=b(),w=yield n.auth.email.loginWithCode(S,d,m?"no-signup":"login-or-sign-up",{embedded:k==null?void 0:k.embedded});return r({status:"done"}),(v=e==null?void 0:e.onLoginSuccess)==null||v.call(e,w.user,w.is_new_user),w==null?void 0:w.user}catch(y){throw s(y)}}),[t,r,n,e,s]);return{sendCode:a,loginWithCode:c,state:o}};import{useCallback as X,useContext as lr,useState as dr}from"react";import{PrivyClientError as Ce}from"@privy-io/js-sdk-core";var Zo=e=>{let[t,i]=dr(""),{client:n,otpState:o,setOtpState:r}=lr(u),s=X(d=>{var m;let g=f(d);return r({status:"error",error:g}),(m=e==null?void 0:e.onError)==null||m.call(e,g),g},[e,r]),a=X(g=>l(void 0,[g],function*({phone:d}){var m;i(d);try{r({status:"sending-code"});let p=yield n.auth.phone.sendCode(d);return r({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{phone:d}),p}catch(p){throw s(p)}}),[n,s,e,r]),c=X(m=>l(void 0,[m],function*({code:d,phone:g}){var p;try{if(!h())throw new Ce({code:"attempted_link_sms_before_logged_in",error:"Must be logged in to link a phone number, Use `useLoginWithSMS` to login with a phone number"});if(!(g||t))throw new Ce({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `linkWithCode`"});r({status:"submitting-code"});let{user:S}=yield n.auth.phone.linkWithCode(g||t,d);return r({status:"done"}),(p=e==null?void 0:e.onLinkSuccess)==null||p.call(e,S),S}catch(v){throw s(v)}}),[t,r,n,e,s]);return{sendCode:a,linkWithCode:c,state:o}};import{useCallback as Y,useContext as ur,useState as mr}from"react";import{PrivyClientError as We}from"@privy-io/js-sdk-core";var ln=e=>{let[t,i]=mr(""),{client:n,otpState:o,setOtpState:r}=ur(u),s=Y(d=>{var m;let g=f(d);return r({status:"error",error:g}),(m=e==null?void 0:e.onError)==null||m.call(e,g),g},[e,r]),a=Y(g=>l(void 0,[g],function*({phone:d}){var m;i(d);try{r({status:"sending-code"});let p=yield n.auth.phone.sendCode(d);return r({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{phone:d}),p}catch(p){throw s(p)}}),[n,s,e,r]),c=Y(p=>l(void 0,[p],function*({code:d,phone:g,disableSignup:m}){var v;try{if(h())throw new We({code:"attempted_login_with_sms_while_already_logged_in",error:"Already logged in, use `useLinkWithSMS` if you are trying to link a phone number to an existing account"});if(!(g||t))throw new We({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `loginWithCode`"});r({status:"submitting-code"});let k=b(),w=yield n.auth.phone.loginWithCode(g||t,d,m?"no-signup":"login-or-sign-up",{embedded:k==null?void 0:k.embedded});return r({status:"done"}),(v=e==null?void 0:e.onLoginSuccess)==null||v.call(e,w.user,w.is_new_user),w==null?void 0:w.user}catch(y){throw s(y)}}),[t,r,n,e,s]);return{sendCode:a,loginWithCode:c,state:o}};import*as G from"expo-linking";import{useCallback as Z,useContext as pr,useRef as gr}from"react";import{PrivyClientError as O}from"@privy-io/js-sdk-core";var yn=e=>{let{appState:t,getCurrentAppState:i}=H(),{client:n,farcasterState:o,setFarcasterState:r}=pr(u),s=gr(!1),a=Z(g=>{var p;let m=f(g);return r({status:"error",error:m}),(p=e==null?void 0:e.onError)==null||p.call(e,m),m},[e==null?void 0:e.onError,r]),c=Z(()=>{s.current=!0},[]);return{linkWithFarcaster:Z((v,...y)=>l(void 0,[v,...y],function*({relyingParty:g,redirectUrl:m},p={pollAttempts:10,pollIntervalMs:1e3}){var S;try{let k=h();if(s.current=!1,!k)throw new O({code:"attempted_link_farcaster_before_logged_in",error:"Must be logged in to link a Farcaster account."});r({status:"generating-uri"});let{connect_uri:w,channel_token:P}=yield n.auth.farcaster.initializeAuth({relyingParty:g,redirectUrl:G.createURL(m!=null?m:"/")});if(!w)throw new O({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!P)throw new O({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield G.openURL(w),r({status:"polling-status"});let U=0;for(;U<p.pollAttempts;){if(s.current)throw new O({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(t.current!=="active"&&i()!=="active"){yield A(p.pollIntervalMs);continue}let M=yield n.auth.farcaster.getFarcasterStatus({channel_token:P});if(M.state==="completed"){r({status:"submitting-token"});let{user:I}=yield n.auth.farcaster.link(_({channel_token:P},M));return r({status:"done"}),(S=e==null?void 0:e.onSuccess)==null||S.call(e,I),I}U++,yield A(p.pollIntervalMs)}throw new O({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(k){throw a(k)}}),[n,e==null?void 0:e.onSuccess,a,r]),state:o,cancel:c}};import{useCallback as Ee,useContext as hr}from"react";var Cn=e=>{let{client:t}=hr(u),i=Ee(o=>{var s;let r=f(o);return(s=e==null?void 0:e.onError)==null||s.call(e,r),r},[e==null?void 0:e.onError]);return{unlinkFarcaster:Ee(r=>l(void 0,[r],function*({fid:o}){var s;try{let{user:a}=yield t.auth.farcaster.unlink({fid:o});return(s=e==null?void 0:e.onSuccess)==null||s.call(e,a),a}catch(a){throw i(a)}}),[t,e==null?void 0:e.onSuccess,i])}};import*as D from"expo-linking";import{useCallback as te,useContext as fr,useRef as yr}from"react";import{PrivyClientError as R}from"@privy-io/js-sdk-core";var Mn=e=>{let{appState:t,getCurrentAppState:i}=H(),{client:n,farcasterState:o,setFarcasterState:r}=fr(u),s=yr(!1),a=te(g=>{var p;let m=f(g);return r({status:"error",error:m}),(p=e==null?void 0:e.onError)==null||p.call(e,m),m},[e==null?void 0:e.onError,r]),c=te(()=>{s.current=!0},[]);return{loginWithFarcaster:te((y,...S)=>l(void 0,[y,...S],function*({relyingParty:g,redirectUrl:m,disableSignup:p},v={pollAttempts:10,pollIntervalMs:1e3}){var k;try{if(s.current=!1,h())throw new R({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use `useLinkWithFarcaster` if you are trying to link farcaster to an existing account"});r({status:"generating-uri"});let{connect_uri:P,channel_token:U}=yield n.auth.farcaster.initializeAuth({relyingParty:g,redirectUrl:D.createURL(m!=null?m:"/")});if(!P)throw new R({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!U)throw new R({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield D.openURL(P),r({status:"polling-status"});let M=0;for(;M<v.pollAttempts;){if(s.current)throw new R({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(t.current!=="active"&&i()!=="active"){yield A(v.pollIntervalMs);continue}let I=yield n.auth.farcaster.getFarcasterStatus({channel_token:U});if(I.state==="completed"){r({status:"submitting-token"});let j=b(),K=yield n.auth.farcaster.authenticate(_({channel_token:U,mode:p?"no-signup":"login-or-sign-up"},I),{embedded:j==null?void 0:j.embedded});return r({status:"done"}),(k=e==null?void 0:e.onSuccess)==null||k.call(e,K.user,K.is_new_user),K.user}M++,yield A(v.pollIntervalMs)}throw new R({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(w){throw a(w)}}),[n,a,e==null?void 0:e.onSuccess,r,t]),state:o,cancel:c}};import{useCallback as Pe,useContext as wr}from"react";import{create as vr}from"zustand";import{PrivyClientError as Sr}from"@privy-io/js-sdk-core";var oe=vr(()=>({status:"initial"})),E=e=>oe.setState(e,!0),kr=oe.getState,Nn=()=>{let{client:e}=wr(u),t=oe(),i=Pe(()=>l(void 0,null,function*(){try{E({status:"fetching-nonce"});let o=yield e.auth.farcasterV2.initializeAuth();return E({status:"awaiting-signature"}),o}catch(o){let r=f(o);throw E({status:"initial",error:r}),r}}),[e]),n=Pe(o=>l(void 0,null,function*(){let r=kr().status;try{if(h()){let d=new Sr({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use a link helper if you are trying to link farcaster to an existing account"});throw E({status:r,error:d}),d}E({status:"submitting-signature"});let a=b(),c=yield e.auth.farcasterV2.authenticate(o,{embedded:a==null?void 0:a.embedded});return E({status:"done"}),setTimeout(()=>E({status:"initial"}),1500),{user:c.user}}catch(s){let a=f(s);throw E({status:r,error:a}),a}}),[e]);return{init:i,login:n,state:t}};import{useCallback as Ue,useContext as br}from"react";var $n=e=>{let{client:t}=br(u),i=Ue(o=>{var s;let r=f(o);return(s=e==null?void 0:e.onError)==null||s.call(e,r),r},[e==null?void 0:e.onError]);return{unlinkOAuth:Ue(s=>l(void 0,[s],function*({provider:o,subject:r}){var a;try{let{user:c}=yield t.auth.oauth.unlink(o,r);return(a=e==null?void 0:e.onSuccess)==null||a.call(e,c),c}catch(c){throw i(c)}}),[t,e==null?void 0:e.onSuccess,i])}};import{useContext as Cr,useEffect as Wr,useRef as Er}from"react";var Zn=e=>{let{client:t}=Cr(u),i=Er(e.onOAuthTokenGrant);i.current=e.onOAuthTokenGrant,Wr(()=>{let{unsubscribe:n}=t.addOAuthTokensListener(o=>{i.current(o)});return n},[t])};import{useContext as Pr,useMemo as Ur}from"react";import{delegatedActions as _e}from"@privy-io/js-sdk-core";var ni=()=>{let{client:e}=Pr(u);return Ur(()=>({delegateWallet:_e.delegateWallet(e),revokeWallets:_e.revokeWallets(e)}),[e])};import{useContext as Mr,useMemo as Ir}from"react";import{addSessionSigners as Or,removeSessionSigners as Rr}from"@privy-io/js-sdk-core";import{getAllUserEmbeddedBitcoinWallets as _r,getAllUserEmbeddedEthereumWallets as xr,getAllUserEmbeddedSolanaWallets as Ar}from"@privy-io/js-sdk-core";function Lr(e,t){return[...xr(e),...Ar(e),..._r(e)].find(n=>n.address===t)}function ne(e){let t=h();if(!t)throw new Error("User must be authenticated to perform this operation");let i=Lr(t,e);if(!i)throw new Error(`No wallet found with address ${e}`);return i}var pi=()=>{let{client:e}=Mr(u);return Ir(()=>({addSessionSigners:({address:t,signers:i})=>Or({client:e,wallet:ne(t),signers:i.map(n=>({signer_id:n.signerId,override_policy_ids:n.policyIds}))}),removeSessionSigners:({address:t})=>Rr({client:e,wallet:ne(t)})}),[e])};import{useContext as Fr,useMemo as Tr}from"react";import{PrivyClientError as Ae}from"@privy-io/js-sdk-core";var vi=()=>{let{client:e}=Fr(u);return Tr(()=>({sendCode(n){return l(this,arguments,function*({newEmailAddress:i}){xe(),yield e.auth.email.sendCode(i)})},updateEmail(o){return l(this,arguments,function*({newEmailAddress:i,code:n}){let{address:r}=xe(),{user:s}=yield e.auth.email.updateEmail({oldEmailAddress:r,newEmailAddress:i,code:n});return s})}}),[e])};function xe(){let t=Hr().linked_accounts.find(i=>i.type==="email");if(!t)throw new Ae({code:"attempted_update_email_without_a_linked_email",error:"Must have a linked email account already to update an email address. Use `useLinkEmail` to link an email account."});return t}function Hr(){let e=h();if(!e)throw new Ae({code:"attempted_update_before_logged_in",error:"Must be logged in to update a user profile."});return e}import{useContext as Br,useMemo as Gr}from"react";import{PrivyClientError as Me}from"@privy-io/js-sdk-core";var Pi=()=>{let{client:e}=Br(u);return Gr(()=>({sendCode(n){return l(this,arguments,function*({newPhoneNumber:i}){Le(),yield e.auth.phone.sendCode(i)})},updatePhone(o){return l(this,arguments,function*({newPhoneNumber:i,code:n}){let{phoneNumber:r}=Le(),{user:s}=yield e.auth.phone.updatePhone({oldPhoneNumber:r,newPhoneNumber:i,code:n});return s})}}),[e])};function Le(){let t=Dr().linked_accounts.find(i=>i.type==="phone");if(!t)throw new Me({code:"attempted_update_phone_without_a_linked_phone",error:"Must have a linked phone account already to update a phone number. Use `useLinkSMS` to link a phone number."});return t}function Dr(){let e=h();if(!e)throw new Me({code:"attempted_update_before_logged_in",error:"Must be logged in to update a user profile."});return e}import*as Re from"expo-linking";import{useCallback as Vr,useContext as zr,useMemo as jr}from"react";import{crossApp as Kr,PrivyClientError as qr}from"@privy-io/js-sdk-core";import*as Oe from"expo-linking";import*as F from"expo-web-browser";import{PrivyClientError as Ie}from"@privy-io/js-sdk-core";var W=(e,t)=>l(void 0,null,function*(){let i=yield F.openAuthSessionAsync(e,t,{createTask:!1});if(i.type!=="success")throw i.type===F.WebBrowserResultType.CANCEL||i.type===F.WebBrowserResultType.DISMISS?new Ie({error:"OAuth session was cancelled",code:"oauth_session_failed"}):new Ie({error:"OAuth session failed",code:"oauth_session_failed"});return Nr(i.url)});function Nr(e){let{queryParams:t}=Oe.parse(e);return t}var Ti=()=>{let{client:e}=zr(u),t=jr(()=>Kr.loginWithCrossAppAuth({client:e,openAuthSession:W}),[e]);return{loginWithCrossApp:Vr(r=>l(void 0,[r],function*({appId:n,redirectUri:o}){if(h())throw new qr({code:"attempted_login_with_cross_app_while_already_logged_in",error:"Already logged in, use `linkCrossAppAccount` if you are trying to link a cross app account to an existing account"});let{user:a}=yield t({providerAppId:n,redirectUrl:Re.createURL(o||"/")});return{user:a}}),[t])}};import*as Fe from"expo-linking";import{useCallback as $r,useContext as Jr,useMemo as Qr}from"react";import{crossApp as Xr,PrivyClientError as Yr}from"@privy-io/js-sdk-core";var ji=()=>{let{client:e}=Jr(u),t=Qr(()=>Xr.linkWithCrossAppAuth({client:e,openAuthSession:W}),[e]);return{linkWithCrossApp:$r(r=>l(void 0,[r],function*({appId:n,redirectUri:o}){if(!h())throw new Yr({code:"attempted_link_cross_app_before_logged_in",error:"Must be logged in to link a cross app account, Use `loginWithCrossAppAccount` to login with cross app"});return{user:yield t({providerAppId:n,redirectUrl:Fe.createURL(o||"/")})}}),[t])}};import*as He from"expo-linking";import{useContext as Zr,useMemo as Te}from"react";import{crossApp as et}from"@privy-io/js-sdk-core";var Zi=()=>{let{client:e}=Zr(u),t=Te(()=>et.wallet.signMessage({client:e,openAuthSession:W}),[e]);return Te(()=>({signMessage:({address:i,message:n,redirectUri:o="/"})=>t({user:h(),address:i,message:n,redirectUrl:He.createURL(o)})}),[t])};import*as Ge from"expo-linking";import{useContext as rt,useMemo as Be}from"react";import{crossApp as tt}from"@privy-io/js-sdk-core";var ss=()=>{let{client:e}=rt(u),t=Be(()=>tt.wallet.signTypedData({client:e,openAuthSession:W}),[e]);return Be(()=>({signTypedData:({address:i,typedData:n,redirectUri:o="/"})=>t({user:h(),address:i,typedData:n,redirectUrl:Ge.createURL(o)})}),[t])};import*as Ne from"expo-linking";import{useContext as ot,useMemo as De}from"react";import{crossApp as nt}from"@privy-io/js-sdk-core";var ps=()=>{let{client:e}=ot(u),t=De(()=>nt.wallet.sendTransaction({client:e,openAuthSession:W}),[e]);return De(()=>({sendTransaction:({address:i,transaction:n,redirectUri:o="/"})=>t({user:h(),address:i,transaction:n,redirectUrl:Ne.createURL(o)})}),[t])};import{useCallback as it,useContext as st}from"react";import{getUserEmbeddedEthereumWallet as at,getUserEmbeddedSolanaWallet as ct,isUnifiedWallet as lt,PrivyClientError as L,throwIfInvalidRecoveryUpgradePath as dt}from"@privy-io/js-sdk-core";var ks=()=>{let{client:e}=st(u);return{setRecovery:it(i=>l(void 0,null,function*(){var a;let n=h(),o=e.app.appId;if(!n)throw new L({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let r=(a=at(n))!=null?a:ct(n);if(!r)throw new L({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(lt(r))throw new L({code:"unsupported_wallet_type",error:"Embedded wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});try{r.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(r):r.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(r,r.address,"solana-address-verifier"))}catch(c){throw new L({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}dt({currentRecoveryMethod:r.recovery_method,upgradeToRecoveryMethod:i.recoveryMethod});let s=yield ut({appId:o,client:e,user:n,primaryAccount:r,recoveryParams:i});try{let{user:c}=yield e.embeddedWallet.setRecovery(s);return{user:c}}catch(c){throw new L({code:"embedded_wallet_set_recovery_error",error:c instanceof Error?c.message:"Error setting password on embedded wallet"})}}),[e])}},ut=r=>l(void 0,[r],function*({appId:e,client:t,user:i,primaryAccount:n,recoveryParams:o}){switch(o.recoveryMethod){case"privy":return{recoveryMethod:"privy",wallet:n};case"user-passcode":return ue(_({},o),{wallet:n});case"google-drive":{let s=yield B(t);return{recoveryMethod:"google-drive",wallet:n,recoveryAccessToken:s}}case"icloud":{let{recoverySecret:s,iCloudRecordName:a}=yield pe({appId:e,client:t,user:i});return{recoveryMethod:"icloud-native",recoverySecretOverride:s,iCloudRecordNameOverride:a,wallet:n}}case"recovery-encryption-key":return{recoveryMethod:"recovery-encryption-key",wallet:n,recoveryKey:o.recoveryKey};default:throw new L({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}});import{useCallback as mt,useContext as pt}from"react";import{getUserEmbeddedEthereumWallet as gt,getUserEmbeddedSolanaWallet as ht,PrivyClientError as T,isUnifiedWallet as ft}from"@privy-io/js-sdk-core";var As=()=>{let{client:e}=pt(u);return{recover:mt(i=>l(void 0,null,function*(){var d;let n=h();if(!n)throw new T({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let o=(d=gt(n))!=null?d:ht(n);if(!o)throw new T({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(ft(o))throw new T({code:"unsupported_wallet_type",error:"User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});let r,s,a,c;switch(i.recoveryMethod){case"user-passcode":s=i.password;break;case"google-drive":a=yield B(e);break;case"icloud":let{recoverySecret:g}=yield ge({client:e,walletAddress:o.address,chainType:o.chain_type});c=g;break;case"recovery-encryption-key":r=i.recoveryKey;break;case"privy":break;default:throw new T({code:"unsupported_recovery_method",error:`Unsupported recovery options ${i}`})}try{o.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(o,s,a,c,r):o.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(o,o.address,"solana-address-verifier",s,a,c))}catch(g){throw new T({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}}),[e])}};import{useContext as yt,useEffect as ie}from"react";var se=(e={})=>{let{wallet:t,createWalletCallbacks:i,recoverWalletCallbacks:n,setWalletRecoveryCallbacks:o}=yt(u),{onCreateWalletSuccess:r,onCreateWalletError:s,onRecoverWalletError:a,onRecoverWalletSuccess:c,onSetWalletRecoverySuccess:d,onSetWalletRecoveryError:g}=e;return ie(()=>{i.current={onSuccess:r,onError:s}},[r,s]),ie(()=>{n.current={onSuccess:c,onError:a}},[c,a]),ie(()=>{o.current={onSuccess:d,onError:g}},[c,a]),t};import{useEffect as wt}from"react";var Hs=({onStateChange:e})=>{let t=se();return wt(()=>{e(t)},[t])};import{useContext as vt}from"react";var Ns=()=>{let{getIdentityToken:e}=vt(u);return{getIdentityToken:e}};import{useCallback as Ve,useContext as St}from"react";import{PrivyClientError as kt}from"@privy-io/js-sdk-core";var Qs=e=>{let{client:t}=St(u),i=Ve(o=>{var s;let r=f(o);return(s=e==null?void 0:e.onError)==null||s.call(e,r),r},[e==null?void 0:e.onError]);return{create:Ve(()=>l(void 0,null,function*(){var o;try{if(h())throw new kt({code:"attempted_to_create_guest_account_for_logged_in_user",error:"Already logged in, you cannot create a guest account"});let s=b(),a=yield t.auth.guest.create({embedded:s==null?void 0:s.embedded});return(o=e==null?void 0:e.onSuccess)==null||o.call(e,a.user,a.is_new_user),a.user}catch(r){throw i(r)}}),[t,i,e==null?void 0:e.onSuccess])}};import{useContext as bt,useEffect as Ct}from"react";function ta({onMfaRequired:e}){let{client:t}=bt(u);Ct(()=>{function i(){return l(this,null,function*(){var o;let n=h();yield e((o=n==null?void 0:n.mfa_methods.map(({type:r})=>r))!=null?o:[])})}return t.mfaPromises.on("mfaRequired",i),()=>{t.mfaPromises.off("mfaRequired",i)}},[t,e])}import{useCallback as N,useContext as Wt}from"react";import{PrivyClientError as V}from"@privy-io/js-sdk-core";function da(){let{client:e}=Wt(u),t=N(r=>l(this,null,function*(){var s,a;switch(r.method){case"sms":yield e.mfa.sms.sendCode({action:"verify"});return;case"passkey":let{options:c}=yield e.mfa.passkey.generateAuthenticationOptions({relying_party:r.relyingParty||((a=(s=b())==null?void 0:s.mfa)==null?void 0:a.relyingParty)});return ye(c);case"totp":return;default:throw new Error(`Unsupported MFA method: ${r.mfaMethod}`)}}),[e]),i=N(r=>l(this,null,function*(){var s,a,c,d,g,m,p;switch(r.method){case"totp":case"sms":if(typeof r.mfaCode!="string")throw new V({code:"invalid_mfa_code",error:"Invalid MFA code"});(c=e.mfaPromises.rootPromise.current)==null||c.resolve({mfaMethod:r.method,mfaCode:r.mfaCode,relyingParty:r.relyingParty||((a=(s=b())==null?void 0:s.mfa)==null?void 0:a.relyingParty)||""}),yield new Promise((k,w)=>{e.mfaPromises.submitPromise.current={resolve:k,reject:w}});break;case"passkey":if(typeof r.mfaCode=="string")throw new V({code:"invalid_passkey_response",error:"Invalid authenticator response"});let v=yield he(r.mfaCode),y=fe(v);(m=e.mfaPromises.rootPromise.current)==null||m.resolve({mfaMethod:r.method,relyingParty:r.relyingParty||((g=(d=b())==null?void 0:d.mfa)==null?void 0:g.relyingParty)||"",mfaCode:y}),yield new Promise((k,w)=>{e.mfaPromises.submitPromise.current={resolve:k,reject:w}});break;default:let S=new V({code:"unsupported_mfa_method",error:"Unsupported MFA method"});throw(p=e.mfaPromises.rootPromise.current)==null||p.reject(S),S}}),[e]),n=N(()=>l(this,null,function*(){yield e.mfa.verifyMfa()}),[e]),o=N(()=>{var r;(r=e.mfaPromises.rootPromise.current)==null||r.reject(new V({code:"mfa_canceled",error:"MFA canceled"}))},[e]);return{init:t,submit:i,prompt:n,cancel:o}}import{useCallback as ae,useContext as Et}from"react";function ha(){let{client:e}=Et(u),t=ae(o=>l(this,null,function*(){switch(o.method){case"sms":case"totp":return yield e.mfa.initEnrollMfa(o);case"passkey":return;default:throw new Error(`Unsupported MFA method: ${o.method}`)}}),[e]),i=ae(o=>l(this,null,function*(){switch(o.method){case"sms":case"totp":case"passkey":yield e.mfa.submitEnrollMfa(o);return;default:throw new Error(`Unsupported MFA method: ${o.method}`)}}),[e]),n=ae(o=>l(this,null,function*(){switch(o.method){case"sms":case"totp":yield e.mfa.unenrollMfa(o.method);return;case"passkey":yield e.mfa.submitEnrollMfa({method:"passkey",credentialIds:[],removeForLogin:o.removeForLogin});return;default:throw new Error(`Unsupported MFA method: ${o.method}`)}}),[e]);return{initMfaEnrollment:t,submitMfaEnrollment:i,unenrollMfa:n}}import{useCallback as Pt,useMemo as Ut}from"react";import{getAllUserEmbeddedEthereumWallets as le,getEntropyDetailsFromUser as ze,getUserEmbeddedSolanaWallet as _t,PrivyClientError as je}from"@privy-io/js-sdk-core";var xt=()=>{let e=x(),t=C(),i=Ut(()=>{let r=le(e).map(s=>{let a=ze(e,s);return a?{account:s,entropy:a}:null});return r.some(s=>s===null)?[]:r.filter(s=>s!==null).map(({account:s,entropy:{entropyId:a,entropyIdVerifier:c}})=>({address:s.address,walletIndex:s.wallet_index,chainType:s.chain_type,getProvider:()=>t.embeddedWallet.getEthereumProvider({wallet:s,entropyId:a,entropyIdVerifier:c,onNeedsRecovery:d=>l(void 0,null,function*(){var g;yield(g=me())==null?void 0:g(d)})})}))},[t,e]),n=Pt((...r)=>l(void 0,[...r],function*({createAdditional:o=!1}={}){let{user:s}=yield t.user.get(),a=le(s);if(!o&&a.length>0)throw new je({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let c=ze(s);if(!c){let y=yield t.embeddedWallet.create({});return ce(y.user,0),{user:y.user}}let{entropyId:d,entropyIdVerifier:g}=c;if(g==="solana-address-verifier"){let y=_t(s),S=yield t.embeddedWallet.create({solanaAccount:y});return ce(S.user,0),{user:S.user}}let p=a.map(y=>y.wallet_index).reduce((y,S)=>Math.max(y,S),0)+1,v=yield t.embeddedWallet.add({chainType:"ethereum",hdWalletIndex:p,entropyId:d,entropyIdVerifier:g});return ce(v.user,p),{user:v.user}}),[t]);return{wallets:i,create:n}};function ce(e,t){let i=le(e).find(n=>n.wallet_index===t);if(!e||!i)throw new je({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"})}import{useContext as At,useEffect as Ke}from"react";var Lt=(e={})=>{let{solanaWallet:t,createSolanaWalletCallbacks:i,recoverSolanaWalletCallbacks:n}=At(u),{onCreateWalletSuccess:o,onCreateWalletError:r,onRecoverWalletError:s,onRecoverWalletSuccess:a}=e;return Ke(()=>{i.current={onSuccess:o,onError:r}},[o,r]),Ke(()=>{n.current={onSuccess:a,onError:s}},[a,s]),t};import{useCallback as Mt,useMemo as It}from"react";import{getAllUserEmbeddedBitcoinWallets as de,getEntropyDetailsFromUser as qe,PrivyClientError as z}from"@privy-io/js-sdk-core";var Ot=()=>{let e=x(),t=C(),i=It(()=>{let o=qe(e);if(!o)return[];let r=de(e),{entropyId:s,entropyIdVerifier:a}=o;return r.map(c=>({address:c.address,walletIndex:c.wallet_index,publicKey:c.public_key,chainType:c.chain_type,getProvider:()=>t.embeddedWallet.getBitcoinProvider({wallet:c,entropyId:s,entropyIdVerifier:a})}))},[t,e]),n=Mt(s=>l(void 0,[s],function*({chainType:o,createAdditional:r=!1}){var k;let a=t.app.getConfig();if(((k=a==null?void 0:a.embedded_wallet_config)==null?void 0:k.mode)==="user-controlled-server-wallets-only")throw new z({code:"unsupported_wallet_type",error:"Bitcoin wallets are only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});let{user:c}=yield t.user.get(),d=qe(c);if(!d)throw new z({code:"embedded_wallet_creation_error",error:"No existing wallet for this user, create an Ethereum walet first to add a Bitcoin wallet"});let{entropyId:g,entropyIdVerifier:m}=d,p=de(c).filter(w=>w.chain_type===o);if(!r&&p.length>0)throw new z({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let v=p.length===0?0:Math.max(...p.map(w=>w.wallet_index),0)+1,y=yield t.embeddedWallet.add({chainType:o,hdWalletIndex:v,entropyId:g,entropyIdVerifier:m}),S=de(y.user).find(w=>w.chain_type===o&&w.wallet_index===v);if(!y.user||!S)throw new z({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"});return{user:y.user,provider:yield t.embeddedWallet.getBitcoinProvider({wallet:S,entropyId:g,entropyIdVerifier:m})}}),[t]);return{wallets:i,create:n}};import{useContext as Rt}from"react";var Ft=()=>{let{isReady:e,logout:t,getAccessToken:i,error:n}=Rt(u);return{user:x(),isReady:e,error:n,logout:t,getAccessToken:i}};import{useMemo as Tt}from"react";import{generateAuthorizationSignature as Ht}from"@privy-io/js-sdk-core";var Bt=()=>{let e=C();return Tt(()=>({generateAuthorizationSignature(i){return l(this,null,function*(){let{signature:n}=yield Ht((...o)=>e.embeddedWallet.signWithUserSigner(...o),i);return{signature:n}})}}),[e])};export{jt as a,eo as b,C as c,mo as d,So as e,_o as f,Fo as g,jo as h,Zo as i,ln as j,yn as k,Cn as l,Mn as m,Nn as n,$n as o,Zn as p,ni as q,pi as r,vi as s,Pi as t,Ti as u,ji as v,Zi as w,ss as x,ps as y,ks as z,As as A,se as B,Hs as C,Ns as D,Qs as E,ta as F,da as G,ha as H,xt as I,Lt as J,Ot as K,Ft as L,Bt as M};
